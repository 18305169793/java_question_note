# 虚拟机类加载机制

**主题** 

  1. 虚拟机如何加载Class文件

  2. Class文件中信息进入虚拟机会发生什么样的变化

**概念** 

虚拟机的类加载机制：虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。

与在编译时需要进行连接工作的语言不同，Java里类的加载、连接和初始化都是在程序运行期间完成的，虽然增加了性能开销，但是会为Java程序提供高度的灵活性，Java天生可以动态扩展的语言特性就是依赖于运行期间动态加载和动态连接这个特点实现。

**约定**

实际情况中，每个Class文件可能是一个接口也可能时一个类

Class文件是一串二进制字节流，不一定在磁盘中

---

---

#### 类加载时机

类的生命周期：加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)、卸载(Unloading),其中验证、准备、解析部分为连接(Linking)

![](/pic/classCircle.PNG)

加载、验证、准备、初始化、卸载五个阶段的顺序时确定的，但执行可以穿插进行，一个阶段会激活另一个阶段。解析可在初始化之前也可在初始化之后，这是为了支持Java语言的运行时动态绑定

类加载，Java虚拟机规范没有强制约束，由具体虚拟机自由实现。

初始化阶段，虚拟机规范严格规定了**有且只有5种**情况必须立即对类进行初始化：

1. 遇到new(实例化对象)、getstatic(读取一个静态字段#已经final修饰或者编译期间变量被放在常量池除外)、putstatic(设置一个静态字段)、invokestatic(调用一个静态方法)这四个字节码指令
2. 使用java.lang.reflect包的方法对类进行反射调用的时候
3. 初始化一个类的时候父类没有初始化，需要先初始化父类
4. 虚拟机启动时，虚拟机会先初始化主类(包含main()方法的类)
5. JDK1.7的动态语言支持时， 如果一个java.lang.invoke.MethodHandle实例解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，方法句柄对应的类没有初始化，需要初始化

***这5种方场景被称为主动引用，此外的引用类的方式称为被动引用，不会触发初始化，称为被动引用***

-XX:+TraceClassLoading  追踪类加载

被动引用例1：子类调用父类静态变量，子类和父类都会加载，但是子类不会初始化，父类会初始化。

![](/pic/super_sub_class_init.PNG)

被动引用例2：SuperClass[] spr = new SuperClass[10] ,创建数组同样不会初始化。

![](/pic/passive2.PNG)

被动引用例3：用户类调用final修饰的静态变量同样不会出发初始化。因为final修饰的变量在编译期间经过了传播优化，将被修饰的值存储到了NotInitilization类的常量池中，之后对常量的引用都会转化为NotInitilization类对自身常量池的引用。NotInitilization类的Class文件没有用户类的符号引用入口，这两个类在编译成Class文件后就没任何联系了。

接口初始化发部分与类相同，但是在一个接口初始化时，不要求其父类全都初始化过，除非引用了父接口中定义的常量。

----

#### 类加载过程

##### 加载过程

1. 通过类的全限定名来获取定义此类的二进制字节流，并没有规定必须从Class文件读取，方式多样，可以从ZIP\JAR\EAR\WAR等包中读取，也可从网络中获取，可以通过动态代理生成，jsp文件生成，数据库中获取等。
2. 将这个字节流所代表的静态存储转化为方法区的运行时数据结构，存在方法区中。
3. 在内存中生成一个代表这个类的java.lang.Class对象(Class对象特殊，没有明确规定要放在堆中，HosSpot虚拟机中时放在方法区，作为程序访问方法区类型数据的外部接口)。



