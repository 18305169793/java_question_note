# 虚拟机类加载机制

**主题** 

  1. 虚拟机如何加载Class文件

  2. Class文件中信息进入虚拟机会发生什么样的变化

**概念** 

虚拟机的类加载机制：虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。

与在编译时需要进行连接工作的语言不同，Java里类的加载、连接和初始化都是在程序运行期间完成的，虽然增加了性能开销，但是会为Java程序提供高度的灵活性，Java天生可以动态扩展的语言特性就是依赖于运行期间动态加载和动态连接这个特点实现。

**约定**

实际情况中，每个Class文件可能是一个接口也可能时一个类

Class文件是一串二进制字节流，不一定在磁盘中

---

---

#### 类加载时机

类的生命周期：加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)、卸载(Unloading),其中验证、准备、解析部分为连接(Linking)

![](/pic/classCircle.PNG)

加载、验证、准备、初始化、卸载五个阶段的顺序时确定的，但执行可以穿插进行，一个阶段会激活另一个阶段。解析可在初始化之前也可在初始化之后，这是为了支持Java语言的运行时动态绑定

类加载，Java虚拟机规范没有强制约束，由具体虚拟机自由实现。

初始化阶段，虚拟机规范严格规定了**有且只有5种**情况必须立即对类进行初始化：

1. 遇到new(实例化对象)、getstatic(读取一个静态字段#已经final修饰或者编译期间变量被放在常量池除外)、putstatic(设置一个静态字段)、invokestatic(调用一个静态方法)这四个字节码指令
2. 使用java.lang.reflect包的方法对类进行反射调用的时候
3. 初始化一个类的时候父类没有初始化，需要先初始化父类
4. 虚拟机启动时，虚拟机会先初始化主类(包含main()方法的类)
5. JDK1.7的动态语言支持时， 如果一个java.lang.invoke.MethodHandle实例解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，方法句柄对应的类没有初始化，需要初始化

***这5种方场景被称为主动引用，此外的引用类的方式称为被动引用，不会触发初始化，称为被动引用***

-XX:+TraceClassLoading  追踪类加载

被动引用例1：子类调用父类静态变量，子类和父类都会加载，但是子类不会初始化，父类会初始化。

![](/pic/super_sub_class_init.PNG)

被动引用例2：SuperClass[] spr = new SuperClass[10] ,创建数组同样不会初始化。

![](/pic/passive2.PNG)

被动引用例3：用户类调用final修饰的静态变量同样不会出发初始化。因为final修饰的变量在编译期间经过了传播优化，将被修饰的值存储到了NotInitilization类的常量池中，之后对常量的引用都会转化为NotInitilization类对自身常量池的引用。NotInitilization类的Class文件没有用户类的符号引用入口，这两个类在编译成Class文件后就没任何联系了。

接口初始化发部分与类相同，但是在一个接口初始化时，不要求其父类全都初始化过，除非引用了父接口中定义的常量。

----

#### 类加载过程

##### 加载

1. **通过类的全限定名来获取定义此类的二进制字节流**，并没有规定必须从Class文件读取，方式多样，可以从ZIP\JAR\EAR\WAR等包中读取，也可从网络中获取，可以通过动态代理生成，jsp文件生成，数据库中获取等。对于非数组类，可以使用系统提供的引导类加载器，也可以使用自定义类加载器。对于数组类，其本身不通过类加载器创建，由java虚拟机创建。如果数组组建类型是引用类型，就递归使用类加载器加载，数组与该类的加载器关联；如果是一般类型，数组标记为引导类加载器关联；数组类的可见性与组件类型一致，非引用类型可见性默认为public
2. 将这个字节流所代表的静态存储转化为方法区的运行时数据结构，存在**方法区**中。
3. 在内存中**生成一个代表这个类的java.lang.Class对象**(Class对象特殊，没有明确规定要放在堆中，HosSpot虚拟机中时放在方法区，作为程序访问方法区类型数据的外部接口)。

##### 验证

验证是连接阶段的第一步，目的是却博爱Class文件的字节流中包含的信息符合当前虚拟机要求，不会危害虚拟机自身安全。验证阶段是非常重要的，这个阶段是否严谨决定了Java虚拟机是否能承受住恶意代码的攻击，验证阶段再虚拟机类加载系统中占了相当大一部分。验证阶段大体上分为4个阶段：文件格式验证、元数据验证、字节码验证、符号引用验证。

1. **文件格式验证**：是否以魔数0xCAFEBABE开头，主次版本号是否在当前虚拟机处理范围内，常量池中是否由不被支持类型，指向常量的各种索引是否存在指向不存在或不符合类型的常量，CONSTANT_Utf8_info型常量是否由不符合UTF8编码的数据，Class文件各个部分及文件本身是否有被删除的或附加的其他信息等。此阶段额主要目的是保证输入的字节流能正确地解析并存储与方法去内，格式上符合Java类型信息要求。这个阶段是基于二进制字节流进行的，只有通过此阶段验证，字节流才会进入方法区存储，而后面三个阶段是基于方法区的存储结构进行的。

2. **元数据验证**：对字节码描述信息进行予以分析，保证其描述的信息符合Java语言规范，其包括，这个类是否有父类、此类的父类是否继承了不允许被继承的类（final修饰）、如果此类不是抽象类是否实现了其父类或接口中所需要实现的所有方法、类中的字段是否与父类产生矛盾。只要对类的元数据信息进行语义教研，保证不存在不符合Java语言规范的元数据信息。
3.  **字节码验证 **：验证过程中最复杂的阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。第二阶段是对元数据信息中的数据类型昨晚校验后，这个阶段将对类的方法体进行校验。包括：保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，不会出现操作栈中放了int型数据，使用时却按照long来载入本地变量表、保证跳转指令不会跳转到方法体以外的字节码指令上、保证方法体的类型转换有效，子类可以赋值给父类，而父类不能复制给子类。**一个类的方法体没有通过字节码验证一定有问题，但是即使通过字节码验证并不能说明其一定没有问题**。
4. **符号引用验证**： 此阶段发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作发生在**解析**阶段，符号引用可看作是对类自身以外的信息进行匹配性校验：符号引用通过字符串的权限定名能否找到对应的类；指定的类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段；符号引用中的类、字段、方法的访问性（四种访问修饰符）是否可被当前类访问。符号引用目的是确保解析动作能正常执行。验证阶段重要但是不一定必要，如果是运行已经被反复验证的代码，可以考虑关闭验证缩短类加载时间 -Xverify:none

##### 准备

此阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量的内存都将在方法区中进行分配。此阶段仅包括类变量（被static修饰），不包括实例变量，再实例变量载Java堆中分配。一般情况下类变量会被设为0，如果被赋予值就是其他值。boolean是fealse，引用类型值为null。如果字段被final修饰，字段属性表中就存在ConstantValue属性，其值就会被初始化为ConstantValue属性所指定的值。

##### 解析

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。

符号引用：用一组符号描述所引用目标，与虚拟机实现的内存布局无关，引用的目标不一定加载到内存中。虽然各个虚拟机实现的内存布局不同，但是能接受的符号引用必须一致，符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。

直接引用：可以是指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄，与虚拟机的内存布局有关，同一符号引用再不同虚拟机实例上翻译出来的直接引用一般不同，如果存在直接引用，引用目标必定在内存中存在。为了避免对一个符号引用多次解析，虚拟机对第一次解析的结果进行缓存。解析动作主要针对类或者**接口、字段、类方法、接口方法**、方法类型、方法句柄和调用点限定符&类符号引用。后三种主要和java的动态语言支持。

1. 类或接口解析

   代码在D类中，需要把从未解析的符号引用N解析为一个类或接口C的直接引用，需要3步

   1. C不是数组，把代表N的权限定名传递给D的类加载器区加载类C
   2. C是一个数组，元素为对象，会按照1.非数组规则加载数组元素类型，接着由虚拟机生成代表此数组维度和元素的数组对象
   3. 如果前两步没有异常，C在虚拟机中已经是一个有效的类了，解析完成前需要进行符号引用验证，确认D是否具有对C的访问权限，否则抛出异常。

2. 字段解析

   解析一个未被解析的字段符号引用会先对**字段表**项中的索引符号引用进行解析，俨然就是字段所属类或者接口的符号引用。假设这个字段所属的类或接口用C表示，解锁过程如下：

   1. 如果C包含了简单名称和字段描述与目标相匹配的字段，则返回这个字段的直接引用，查找结束。

   2. 如果C实现了接口，会按照继承关系从下往上记过搜索各个接口和父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束

   3. 如果C不是对象，将会按照继承关系从下往上递归搜索其父类。如果父类包含了包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束

   4. 查找失败，抛出java.lang.NoSuchFieldError

      查找完成还会进行权限验证，不符合的抛出java.lang.IllegalAccessError

3. 类方法解析

   与字段解析的第一部一样，需要先解析出类方法表的class_index中索引的方法所属的类或接口的符号引用，如果解析成功，虚拟机按照以下步骤搜索：

   1. 类方法和接口方法的符号引用是分开的，如果类方法表中发现class_index中索引的C是个接口，会抛出java.lang.IncompatibleClassChangeError异常；
   2. 如果第一步类C中查找是否有简单名称和描述符都与目标相匹配的方法，有则直接返回该方法的直接引用查找结束；
   3. 在C类的父类中递归查找简单名称和描述符都与目标相匹配的方法，有则返回这个引用，查找结束；
   4. 在C类实现的接口类列表中和父类接口递归查找，有则说明C是抽象类，查找结束，抛出java.lang.AbstractMethodError

   

4. 接口方法解析

   接口方法也需要先解析出方法表的class_index项中索引的方法所属的类或接口的符号引用，成功则依然用C表示这个接口，家下来虚拟机以以下步骤进行后续接口方法搜索。

   1. 与类方法不同，接口方法表中发现class_index中送索引C是个类为不是接口，抛出java.lang.IncompatibleClassChangeError异常；

   2. 在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，有则直接返回该方法的直接引用，查找结束；

   3. 在接口C父接口中递归查找，直到java.lang.Object类为止，看是否有简单名称和描述符都与目标相匹配的方法，有则直接返回该方法的直接引用，查找结束；

   4. 宣告方法查找失败java.lang.NoSuchMethodError异常

      由于接口中所有方法都是public，不存在权限问题，隐私接口方法不会抛出java.lang.IllegalAccessError

##### 初始化



