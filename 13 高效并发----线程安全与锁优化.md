# 13 高效并发----线程安全与锁优化

#### 线程安全

java语言中操作共享数据由强至弱分为以下5类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立

* #### 不可变

例如final修饰的对象，只要创建出来，外部可见状态勇冠不会变，多线程中永远不会出现不一致的情况

* #### 线程绝对安全

* #### 相对线程安全

通常意义上讲的线程安全，保证对象单独操作是线程安全的，多线程方式调用需要同步手段。java语言中大部分线程安全类都属于这种类型，Vector，HashMap，Collections的sychronizedCollection()方法包装的集合

* #### 线程包容

对象本身不是线程安全的，段永段使用同步手段来保证兵法情况下线程安全。ArrayList，HashMap等

* #### 线程对立

指无论采取同步措施与否都无法并发使用代码

___

___

#### 线程安全实现方式

1.互斥同步 blocking synchronization 悲观锁

* synchronized：同步块前后被monitorenter和monitorexit这两个字节码指令包裹，这两个字节码指令需要reference类型参数指明锁定的对象。如果java程序中指明了对象参数，那就是对象的reference，没有指明的话，就看synchronized修饰的方法是实例方法还是类方法，区获取对应的对象实例还是Class对象作为reference。执行monitorenter指令需要先获得对象锁，或者已经有锁，则锁的计数器加一，在遇到monitorexit时，计数器减一，计数器为0锁释放。如果获取对象锁失败，当前线程阻塞等待，直到有线程释放锁。同一个线程可以重入同步块，不会出现把自己锁死的情况。线程阻塞和唤醒操作与cpu线程操作时映射关系，需要用户态和核心态相互转换，耗费很多处理器时间，所以synchronized是一个重量级操作。
* J.U.C包的重入锁也可以实现互斥，java.util.concurrent.locks.ReentrantLock类的lock()与unlock()方法。重入锁可以实现等待中断，公平锁，绑定条件。

2.非阻塞同步 non-blocking synchronization乐观锁

需要指令集有比较并交换（CAS）或加载链接/条件存储（LL/SC）的支持

CAS     变量内存地址V，    旧的预期值A，   新的预期值B 

当且仅当V中的值与A符合，用B更新V，否则返回V的旧值

sun.misc.Unsafe类可以实现相关CAS指令，但是Unsafe不是用户调用的类，get方法限制了启动类加载器才可以加载

java.util.concurrent.atomic.AtomicInteger的incrementAndGet()方法就是此类实现

但是CAS也有缺点，就是值未改变不意味着没有更改过，ABA问题

3.无同步方案

线程之间没有因果关系就，代码就不需要同步此类代码称为可重入代码Reentrant Code，或者叫纯代码。在执行的任何时刻取中段它，转而执行另一段代码（包括递归自己），返回后程序不会出现任何错误。可重入代码具有一些共有特征：如果一个方法，它的返回结果是可预测的，只要输入相同的数据，都能返回相同的结果，就满足可重入要求。

线程本地存储(Thread Local Storage)：如果代码中数据与其他代码共享，这些共享数据的代码如果能在同一个线程中运行，把数据可见性限制在同一个线程之内，就能避免线程同步的问题。ThreadLocal类！！！



----

----

#### 锁优化

* 自旋锁与自适应自旋---自旋不能完全替代阻塞

* 锁消除
* 锁粗化
* 轻量级锁---偏向锁



